// Copyright 2025 Red Hat Inc.
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"fmt"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"slices"
	"strings"
	"time"

	mmv1product "github.com/GoogleCloudPlatform/magic-modules/mmv1/api/product"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/thekad/ansible-mmv1/pkg/ansible"
	"github.com/thekad/ansible-mmv1/pkg/api"
	tpl "github.com/thekad/ansible-mmv1/pkg/template"
)

const MMV1_REPO string = "https://github.com/GoogleCloudPlatform/magic-modules"
const MIN_VERSION string = "beta"

// ProductConfig holds per-product configuration with optional resource list
type ProductConfig struct {
	Name      string   `mapstructure:"name"`
	Resources []string `mapstructure:"resources"`
}

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "ansible-mmv1",
	Short: "Generate Ansible modules from Magic Modules",
	Long: `ansible-mmv1 generates Ansible modules from Google's Magic Modules repository.
It reads product and resource definitions and generates Python modules and integration tests.`,
	PreRun: func(cmd *cobra.Command, args []string) {
		initLogging(cmd)
	},
}

func init() {
	cobra.OnInitialize(initConfig)

	// Set the run function here to avoid initialization cycle
	rootCmd.Run = runGenerate

	// Git flags
	rootCmd.Flags().String("git-url", MMV1_REPO, "git repository to clone")
	rootCmd.Flags().String("git-dir", "magic-modules", "path to clone magic modules repo")
	rootCmd.Flags().String("git-rev", "main", "git revision to checkout")
	rootCmd.Flags().Bool("git-pull", false, "git pull before checkout")

	// Path flags
	rootCmd.Flags().StringP("output", "o", "output", "path to write autogenerated files")
	rootCmd.Flags().StringP("overrides", "O", "overrides", "path to override files")
	rootCmd.Flags().StringP("templates", "T", "templates", "path to template files")

	// Generation flags
	rootCmd.Flags().StringSlice("products", []string{}, "comma-separated list of products to generate")
	rootCmd.Flags().StringSlice("resources", []string{}, "comma-separated list of resources to generate")
	rootCmd.Flags().Bool("no-code", false, "skip code generation")
	rootCmd.Flags().Bool("no-tests", false, "skip test generation")
	rootCmd.Flags().Bool("no-format", false, "skip formatting files (i.e. black/yamlfmt)")
	rootCmd.Flags().Bool("overwrite", false, "overwrite existing files")
	rootCmd.Flags().String("min-version", MIN_VERSION, "minimum version to generate")

	// Logging flag
	rootCmd.Flags().StringP("log-level", "l", "info", "log level (trace, debug, info, warn, error, fatal)")

	// Config file flag
	rootCmd.Flags().StringP("config", "C", "", "path to config file")

	// Bind flags to viper (only for options that can come from config file)
	viper.BindPFlag("git.url", rootCmd.Flags().Lookup("git-url"))
	viper.BindPFlag("git.dir", rootCmd.Flags().Lookup("git-dir"))
	viper.BindPFlag("git.rev", rootCmd.Flags().Lookup("git-rev"))
	viper.BindPFlag("git.pull", rootCmd.Flags().Lookup("git-pull"))
	viper.BindPFlag("overrides", rootCmd.Flags().Lookup("overrides"))
	viper.BindPFlag("templates", rootCmd.Flags().Lookup("templates"))
	viper.BindPFlag("overwrite", rootCmd.Flags().Lookup("overwrite"))
	// Note: output, min-version, no-code, no-tests, no-format are flag-only (not in config file)
}

func initLogging(cmd *cobra.Command) {
	logLevelStr, _ := cmd.Flags().GetString("log-level")

	log.Logger = log.Output(zerolog.ConsoleWriter{
		Out:        os.Stderr,
		TimeFormat: time.RFC3339,
	})

	switch strings.ToLower(logLevelStr) {
	case "trace":
		zerolog.SetGlobalLevel(zerolog.TraceLevel)
	case "debug":
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case "info":
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case "warn":
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case "error":
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	case "fatal":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	case "panic":
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	default:
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
		log.Warn().Msgf("Unrecognized log level '%s', defaulting to 'info'", logLevelStr)
	}

	log.Debug().Msgf("Log level set to %s", zerolog.GlobalLevel())
}

func initConfig() {
	// Check for config file flag
	configFile, _ := rootCmd.Flags().GetString("config")
	if configFile != "" {
		viper.SetConfigFile(configFile)
	}

	// Read config file (if it exists)
	if err := viper.ReadInConfig(); err != nil {
		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
			// Config file was found but another error occurred
			log.Warn().Err(err).Msg("error reading config file")
		}
	} else {
		log.Info().Msgf("using config file: %s", viper.ConfigFileUsed())
	}
}

// buildProductResourceMap builds a map of product names to their resource lists
func buildProductResourceMap(products []ProductConfig) map[string][]string {
	prm := make(map[string][]string)
	for _, p := range products {
		// Normalize resource names to lowercase
		resources := make([]string, len(p.Resources))
		for i, r := range p.Resources {
			resources[i] = strings.ToLower(r)
		}
		prm[strings.ToLower(p.Name)] = resources
	}
	return prm
}

// getProductNames extracts product names from config
func getProductNames(products []ProductConfig) []string {
	names := make([]string, len(products))
	for i, p := range products {
		names[i] = strings.ToLower(p.Name)
	}
	return names
}

// getProductsConfig returns the products configuration, handling both
// config file format (products with nested resources) and CLI format (flat lists)
func getProductsConfig(cmd *cobra.Command) []ProductConfig {
	// First check if products are defined in config file format
	var configProducts []ProductConfig
	if err := viper.UnmarshalKey("products", &configProducts); err == nil && len(configProducts) > 0 {
		return configProducts
	}

	// Fall back to CLI-style flat lists
	productNames, _ := cmd.Flags().GetStringSlice("products")
	resourceNames, _ := cmd.Flags().GetStringSlice("resources")

	// Normalize to lowercase
	for i, p := range productNames {
		productNames[i] = strings.ToLower(strings.TrimSpace(p))
	}
	for i, r := range resourceNames {
		resourceNames[i] = strings.ToLower(strings.TrimSpace(r))
	}

	// Build ProductConfig list from CLI args
	products := make([]ProductConfig, len(productNames))
	for i, p := range productNames {
		products[i] = ProductConfig{
			Name:      p,
			Resources: resourceNames, // all products share the same resource filter
		}
	}
	return products
}

// doGitClone clones the git repository to the given path
func doGitClone(path string, ref string, pull bool, url string) error {
	log.Info().Msgf("git-clone %s to %s\n", url, path)
	_, err := git.PlainClone(path, false, &git.CloneOptions{
		URL:      url,
		Progress: os.Stdout,
	})
	if err != nil {
		log.Warn().Msgf("git-clone: %s", err)
	}

	repo, err := git.PlainOpen(path)
	if err != nil {
		return fmt.Errorf("can't open git dir %s: %v", path, err)
	}

	worktree, err := repo.Worktree()
	if err != nil {
		return fmt.Errorf("can't open worktree: %v", err)
	}

	if pull {
		if err := worktree.Pull(&git.PullOptions{RemoteName: "origin"}); err != nil {
			return fmt.Errorf("can't pull from 'origin' remote: %v", err)
		}
		log.Info().Msg("git-pull: success")
	}

	h, err := repo.ResolveRevision(plumbing.Revision(ref))
	if err != nil {
		return fmt.Errorf("can't resolve revision %s: :%v", ref, err)
	}

	coOpts := git.CheckoutOptions{
		Hash:  *h,
		Force: true,
	}
	if err := worktree.Checkout(&coOpts); err != nil {
		return fmt.Errorf("can't checkout worktree: %v", err)
	}

	log.Info().Msgf("git-checkout %s: success", ref)

	return nil
}

// doFindProducts finds the matching product.yaml files in the given git directory
func doFindProducts(gitDir string, names []string, templateDir string, overridesDir string) ([]*api.Product, error) {
	products := []*api.Product{}

	allFiles, err := filepath.Glob(fmt.Sprintf("%s/mmv1/products/**/product.yaml", gitDir))
	if err != nil {
		return nil, err
	}

	for _, pf := range allFiles {
		pName := filepath.Base(filepath.Dir(pf))
		if len(names) == 0 || slices.Contains(names, pName) {
			p := api.NewProduct(pf, templateDir, overridesDir)
			products = append(products, p)
		}
	}

	return products, nil
}

// doPopulateResourcesByProduct populates the resources for the given product
// If resourceNames is empty, all resources are included
func doPopulateResourcesByProduct(gitDir string, product *api.Product, resourceNames []string) error {
	allFiles, _ := filepath.Glob(fmt.Sprintf("%s/mmv1/products/%s/*.yaml", gitDir, product.Name))
	for _, rf := range allFiles {
		if filepath.Base(rf) == "product.yaml" {
			continue
		}
		rName := strings.TrimSuffix(filepath.Base(rf), filepath.Ext(filepath.Base(rf)))
		// If resourceNames is empty, include all resources; otherwise filter by name
		if len(resourceNames) == 0 || slices.Contains(resourceNames, strings.ToLower(rName)) {
			r := api.NewResource(rf, product, product.TemplateDir, product.OverridesDir)
			if r == nil {
				continue
			}
			product.Resources = append(product.Resources, r)
		}
	}

	return nil
}

func runGenerate(cmd *cobra.Command, args []string) {
	// Get configuration values from viper (config file + flags merged)
	gitURL := viper.GetString("git.url")
	gitDir := viper.GetString("git.dir")
	gitRev := viper.GetString("git.rev")
	gitPull := viper.GetBool("git.pull")
	overridesPath := viper.GetString("overrides")
	templatesPath := viper.GetString("templates")
	overwrite := viper.GetBool("overwrite")

	// Get flag-only values (not available in config file)
	output, _ := cmd.Flags().GetString("output")
	noCode, _ := cmd.Flags().GetBool("no-code")
	noTests, _ := cmd.Flags().GetBool("no-tests")
	noFormat, _ := cmd.Flags().GetBool("no-format")
	minVersion, _ := cmd.Flags().GetString("min-version")

	// Get products configuration
	productsConfig := getProductsConfig(cmd)
	productResources := buildProductResourceMap(productsConfig)
	productNames := getProductNames(productsConfig)

	absDir, _ := filepath.Abs(gitDir)
	templateDir, _ := filepath.Abs(templatesPath)
	overrideDir, _ := filepath.Abs(overridesPath)

	if err := doGitClone(absDir, gitRev, gitPull, gitURL); err != nil {
		log.Fatal().Err(err).Msg("failed to clone git repository")
	}

	productsToGenerate, err := doFindProducts(absDir, productNames, templateDir, overrideDir)
	if err != nil {
		log.Fatal().Err(err).Msg("failed to find products")
	}
	log.Debug().Msgf("matching products: %v", productsToGenerate)

	log.Info().Msgf("template directory is %v", templateDir)

	templateData := tpl.NewTemplateData(templateDir, output, overwrite)
	log.Debug().Msgf("template data: %v", templateData)

	// build list of modules to generate
	modulesToGenerate := []*ansible.Module{}
	minVersionObj := &mmv1product.Version{Name: minVersion}
	for _, p := range productsToGenerate {
		// Get resource list for this product (empty means all resources)
		resourceList := productResources[strings.ToLower(p.Name)]

		// populate resources for given products
		err := doPopulateResourcesByProduct(gitDir, p, resourceList)
		if err != nil {
			log.Fatal().Err(err).Msg("failed to populate resources for product")
		}
		log.Debug().Msgf("matching resources for %s: %v", p.Name, p.Resources)

		// unmarshal product structs
		err = p.Unmarshal()
		if err != nil {
			log.Fatal().Err(err).Msg("failed to unmarshal product")
		}

		for _, r := range p.Resources {
			// unmarshal resource structs
			err := r.Unmarshal()
			if err != nil {
				log.Fatal().Err(err).Msg("failed to unmarshal resource")
			}

			// check if the resource has a minimum version that is not supported by the product
			if r.Mmv1.NotInVersion(minVersionObj) {
				log.Warn().Msgf("resource %s.%s minimum version is %v, but %s is required", r.Parent.Name, r.Name, r.MinVersion(), minVersion)
				continue
			}

			// generate module struct
			module := ansible.NewFromResource(r)
			module.MinVersion = r.MinVersion()
			modulesToGenerate = append(modulesToGenerate, module)
		}
	}
	// generate modules

	for _, m := range modulesToGenerate {
		// generate code for resources
		if !noCode {
			log.Info().Msgf("generating code for ansible module: %s", m)
			err := templateData.GenerateCode(m)
			if err != nil {
				log.Fatal().Err(err).Msg("failed to generate code for ansible module")
			}

			if !noFormat {
				filePath := path.Join(templateData.ModuleDirectory, fmt.Sprintf("%s.py", m.Name))
				log.Info().Msgf("formatting ansible module file: %s", filePath)
				err := formatFile(filePath, "black")
				if err != nil {
					log.Fatal().Err(err).Msg("failed to format code for ansible module")
				}
			}
		}
		// generate tests for resources
		if !noTests {
			log.Info().Msgf("generating tests for ansible module: %s", m)
			err := templateData.GenerateTests(m)
			if err != nil {
				log.Fatal().Err(err).Msg("failed to generate tests for ansible module")
			}

			if !noFormat {
				dirPath := path.Join(templateData.IntegrationTestDirectory, m.Name)
				log.Info().Msgf("formatting integration tests for %s", m.Name)
				err := formatFile(dirPath, "yamlfmt")
				if err != nil {
					log.Fatal().Err(err).Msg("failed to format integration tests for ansible module")
				}
			}
		}
	}
}

func formatFile(filePath string, formatType string) error {
	log.Debug().Msgf("running %s on file: %s", formatType, filePath)
	switch formatType {
	case "black":
		if blackCmd := which("black"); blackCmd == "" {
			return fmt.Errorf("black not found in PATH")
		} else {
			return runCommand(fmt.Sprintf("%s --quiet %s", blackCmd, filePath), filepath.Dir(filePath))
		}
	case "yamlfmt":
		if yamlFmtCmd := which("yamlfmt"); yamlFmtCmd == "" {
			return fmt.Errorf("yamlfmt not found in PATH")
		} else {
			return runCommand(fmt.Sprintf("yamlfmt %s", filePath), filePath)
		}
	}
	return nil
}

// which searches for the given executable and returns the full path to it
// Returns empty string if the command is not found
func which(name string) string {
	if path, err := exec.LookPath(name); err == nil {
		return path
	}

	return ""
}

func runCommand(command string, dir string) error {
	parts := strings.Split(command, " ")
	cmd := exec.Command(parts[0], parts[1:]...)

	// Set working directory if provided
	if dir != "" {
		log.Debug().Msgf("changing directory to: %s", dir)
		cmd.Dir = dir
	}

	log.Debug().Msgf("running command: %s", command)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func main() {
	if err := rootCmd.Execute(); err != nil {
		log.Fatal().Err(err).Msg("command failed")
	}
}
